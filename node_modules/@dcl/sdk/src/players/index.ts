import { Entity, IEngine, TransformType, engine } from '@dcl/ecs'
import {
  PlayerIdentityData as definePlayerIdenityData,
  AvatarBase as defineAvatarBase,
  AvatarEquippedData as defineAvatarEquippedData,
  PBAvatarBase,
  PBAvatarEquippedData,
  Transform as defineTransform
} from '@dcl/ecs/dist/components'

type GetPlayerDataReq = {
  userId: string
}
export type GetPlayerDataRes = {
  entity: Entity
  name: string
  isGuest: boolean
  userId: string
  avatar?: PBAvatarBase
  wearables: PBAvatarEquippedData['wearableUrns']
  emotes: PBAvatarEquippedData['emoteUrns']
  position: TransformType['position'] | undefined
}

function definePlayerHelper(engine: IEngine) {
  const Transform = defineTransform(engine)
  const PlayerIdentityData = definePlayerIdenityData(engine)
  const AvatarEquippedData = defineAvatarEquippedData(engine)
  const AvatarBase = defineAvatarBase(engine)
  const playerEntities = new Map<Entity, string>()

  let onEnterSceneCb: ((player: GetPlayerDataRes) => void) | undefined = undefined
  let onLeaveSceneCb: ((userId: string) => void) | undefined = undefined

  engine.addSystem(
    () => {
      const players = [...engine.getEntitiesWith(PlayerIdentityData, AvatarBase)]

      players.forEach(([entity, identity]) => {
        if (!playerEntities.has(entity)) {
          playerEntities.set(entity, identity.address)

          if (onEnterSceneCb) {
            try {
              onEnterSceneCb(getPlayer({ userId: identity.address })!)

            } catch (e) {
              console.error(e)
            }
          }
        }
      })

      playerEntities.forEach((address, entity) => {
        if (!players.some(([, identity]) => identity.address === address)) {
          if (onLeaveSceneCb) {
            try {
              onLeaveSceneCb(playerEntities.get(entity)!)

            } catch (e) {
              console.error(e)
            }
          }

          playerEntities.delete(entity)
        }
      })
    },
    Number.MAX_VALUE
  )

  return {
    onEnterScene(cb: (player: GetPlayerDataRes) => void) {
      onEnterSceneCb = cb
    },
    onLeaveScene(cb: (userId: string) => void) {
      onLeaveSceneCb = cb
    },
    /**
     * Returns the info of the player if it's in the scene.
     */
    getPlayer(user?: GetPlayerDataReq): GetPlayerDataRes | null {
      function getEntity() {
        if (!user?.userId) return engine.PlayerEntity
        for (const [entity, data] of engine.getEntitiesWith(PlayerIdentityData)) {
          if (data.address === user.userId) {
            return entity
          }
        }
        return undefined
      }

      const userEntity = getEntity()
      if (!userEntity) return null

      const playerData = PlayerIdentityData.getOrNull(userEntity)
      const avatarData = AvatarBase.getOrNull(userEntity)
      const wearablesData = AvatarEquippedData.getOrNull(userEntity)

      if (!playerData && !avatarData && !wearablesData) return null

      return {
        entity: userEntity,
        name: avatarData?.name ?? '',
        isGuest: !!playerData?.isGuest ?? false,
        userId: playerData?.address ?? '',
        avatar: avatarData ?? undefined,
        wearables: wearablesData?.wearableUrns ?? [],
        emotes: wearablesData?.emoteUrns ?? [],
        position: Transform.getOrNull(userEntity)?.position
      }
    }
  }
}

const players = definePlayerHelper(engine)
const { getPlayer, onEnterScene, onLeaveScene } = players

export { getPlayer, onEnterScene, onLeaveScene }
export default players
